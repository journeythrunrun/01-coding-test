# 오른쪽, 아래쪽으로만 움직여서 -> 최단경로의 개수 % 1000000007



# m이 열 n이 행 # N=만 -> O(n log n), n^2아슬
# map만들고  ->
# dp_ 각 map 위치에 최소인 . set
# bfs _ 그 같은 자식들 수 
# (오른쪽이랑 아래쪽으로만 움직여서 가능한 방법)어디서 내려오느냐로 카운팅 & 물웅덩이 개수로 빼서 최적화


    # 2) 
    # m1_X)_너무 최적화하려는 방법은 (웅덩이 등의) 고려할 조건 케이스에 따라 안될 가능성 높음.
    # (n-1)*m# 각 행에서 m개의 열 중에 1개. 행은 1개 빼야함(내려가서 도착하는 위치기준으로 카운팅이기에.)
    # & 단순 m곱하기에는 아래층의 왼쪽에 있는건 못골라서 나머지 열개수에서 골라야함 
    # 근데 물웅덩이가 끝에 있느냐에 따라서 
    
    # m2) -1웅덩이 반영된 map저장. dp맵 거치며 값 저장해나가기. 이전값*(_->곱하기로 하려면 해당 거에 관련된 피연산자값에 해당하는 경우의 수 두개를 다 알아야함. 차근차근 전개하기에 당장 해당 위치 시점에서는  모르는 것도 있으므로 더해나가기.)
    # -> for문 두개로 완전 탐색하며 두 이동경로에 대한 거 -> dp에 계산해나가기
    # m2_m1_X시복초과) 걍 빨리 아는 방법 bfs로 map거쳐서 도착할 때마다(dfs방문했던곳도방문하게) 카운팅할래에? 시복 더 안좋 _ dp좀써보자
    # m3_X)하다가 뭐때문에 안될 수 있을 거 같아서 말았음. 이틀 뒤라 가볍게 한 케이스 생각했던 거 기억은 안나네 ) 아래로 갈 수 있을 때 +1한 거 그 위치에 저장 ~~ 아래로 갈때 자신에서 +1하기 . 마지막 위치에 도달했을 때 answer에+=
    
    ## m_X bfs로 미방문만 가면서 저장_ 미방문만 X 중복 도착해서 경우의 수 추가
    # 3)
    # 가로 세로 전체로 뒤집어도 결과는 같음.
    # 눈에 보이는 가로 4개를 행이 4개인거라고 치고 하자 (데이터 입력 앞위치가 그거임)
#1from collections import deque
def solution(m, n, puddles):
    if  len(puddles[0])==0:
        return 1

    dr,dc=[1,0],[0,1] # 우측 , 아래
    amap=[ [0]*n for _ in range(m) ]
    #visited=[ [False]*n for _ in range(m) ]
    
    dp=[ [0]*n for _ in range(m) ]
    
    for puddle in puddles :
        amap[puddle[0] -1 ][puddle[1] -1 ]=-1 # - 문제 읽을 때 인덱스 -1 미리 적어두자
    
    #aque=deque([ [0,0]  ])
    #visited[0][0]=True
    dp[0][0]=1
    #X 시복초과한 중복방문 bfs법 -> 수정 or 미방문만 : 방문했던 곳이면 append는 안하고 카운팅만추가..? 그럼 값이 다른데
    
    for r in range(m) :
        for c in range(n ) :
            if amap[r][c]==-1:
                continue                
            v=[r,c]
            for i in range(2):
                nr, nc = v[0]+dr[i], v[1]+dc[i]
                if 0<=nr<m and 0<=nc<n and amap[nr][nc]!=-1 : # - 코드수정때 그 앞뒤!! 꼭1_2_3 보듯 다 봐라 쫌. # - 우측, 아래만으로 가는 거라 한 방향으로만 가는 거라서 dp로 for완전탐색 가능. # - bfs 대신 2중 for문으로 하면 완전탐색 완성 기반이라 visited 필요 없어짐
                    #if visited[nr][nc]==True : 
                    dp[nr][nc]+=dp[v[0]][v[1]] # - ! 수정 때 dp[nr][nc] 생각했던 거랑 세부적으로 다른 값을 복사했었 ㅜ. 내부 까지 무슨값인지 자세히 보고 복붙해라. 걍 하나하나 타이핑 하든. # 1이 아니라 현재값. 이전 시복 초과법처럼 각 경우의 수 전부 쭉 가는 거 아님. # - 경우의 수 0->1넘어가기는 +1하는 대신 처음에 초기값이 1인상태로 전파시키는중 
                    # else: # - 처음방문한 곳이어도 이때까지의 값.  
                    # dp[nr][nc]+=dp[v[0]][v[1]] # 1이 아니라 현재값. # 꼭 누적
                    #visited[nr][nc]=True  
                    # m_백트래킹으로 해야하나..
            
    
#     while(aque):
#         #print(dp)
#         v= aque.popleft() 
#         # m 부모의 값을 자식에게 더해줌
#         # 3) x_현재 위치 기준으로 dr의 두방향 다 갈 수 있으면 +1
#         # 라기보다 차라리 방문한곳 또 방문했을 때 거기에 +1 _ 방향특성상돌아가는 건 없다
#         #print(v)
        
#         # 이 방법 조회 순서에 따라#~#~ 중복이 너무 많다. bfs, dfs, 초기에 넣어놓은값 방법 말구 단순 for?
        
#         for i in range(2):
#             nr, nc = v[0]+dr[i], v[1]+dc[i]
#             if 0<=nr<m and 0<=nc<n and amap[nr][nc]!=-1 : # : 코드수정때 그 앞뒤!!꼭123#똑같은 곳 가야하고 뒤로가는거어차피 없어서미방문체크 안해도  visited[nr][nc]==False :
#                 if visited[nr][nc]==True : #i==1:## 두번째가 2가아니라 1이지
#                     #print( dp[v[0]][v[1]]+1 )
#                     dp[nr][nc]+=1##dp[v[0]][v[1]]#+1대신 처음에 초기값이 1인상태로 전파시키는중 # 내려갈 땐 +=는 안해도 
#                 else:
#                     dp[nr][nc]=1#+=dp[v[0]][v[1]] # 꼭 누적
#                 aque.append([nr,nc])
#                 visited[nr][nc]=True                #~ 방문순서와 다르게, 닿는 순서 때문에 여기서 꼭? 
#                 # 기본 pop, append안한거 실화
#     # 22아닌 퍼들값 체크
#     #~aset=set([ [1,2],[1,2],[3,4] ])# 튜플 ㄱㄴ 리스트 ㅂㄱㄴunhashable
#     ##print(aset)
    return dp[-1][-1]% 1000000007
# 4) m, n 1,1아닌 1,k,2
# 물에 잠긴지역 0개일 때 /결과0일떄 완료_중복 물 -> set



# - 저 나눌 값 연산 범위 이려나 -> 설마 코테에서 그렇게 더럽게 문제 내겠어 and print로 나눠봐도 되지


# - 1h 25m (+4점) : 1h제한 풀기로 체크 몇 개 이틀 뒤에 이어서 풀다가 좀 더 걸린듯(복붙도 이상한인덱스로해버림) '4)체크랑  % 1000000007'

#   + 59m : 시복초과한 풀이법. 널널하다고 널널하다고만 생각하지 말고, 시복 계산하자. 
#     + (생각난 여러 방법 중, 빠르게 한 개 픽하지 않고 여러 방법 이어서 생각하다가 시간 들여진듯. 빨리 확실히 픽하지 못할 각 방법 생각 전개였을 수도 있긴 함._풀이법을 계속 bfs로만 전개한 건가. 풀이법 초반에만 bfs로 하고, 효율성은 나중에 생각하고 그 후엔 시복 조건 만족하는 dfs로 하던가하자..)

#   + 1h 제한 문제 풀기(수학문제 처럼 끊는 거 잘 못했는데 보상 거니까 잘되네.)

# - DP!!!!  => !!!!!!!!!점화식!!!!!!!!!

# - 다른 사람 풀이 [정성환 , 이동훈 , 이경서 , 이경서 외 24 명]
#   + 인덱스 헷갈리니까 걍 index 1,1 부터 사용 . & k-1인덱스 사용하는 점화식때 첫 실제 줄의 값도 연산되기 위해 0 패딩 유사.
#      >  = [[0]*(m+1) for i in range(n+1)]

#   + 점화식 사용. 일방향 유사 조건에서 가능했던 내 간이 dp말고 찐 점화식 dp네. 
#     + 점화식 덧셈에 문제 없기 위해, 물웅덩이 때의 dp값을 0으로하면 ㄱㅊ
#   + 애초에 dp에도 그 큰 수 나눈 나머지의 값으로 저장
#     + 더하기가 결합된 것의 괄호 밖 나누기(~~나머지)를 괄호 안으로 분배해도 결과 같음. 

# def solution(m,n,puddles):
#     grid = [[0]*(m+1) for i in range(n+1)] #왼쪽, 위로 한줄씩 만들어서 IndexError 방지
#     if puddles != [[]]:                    #물이 잠긴 지역이 0일 수 있음
#         for a, b in puddles:
#             grid[b][a] = -1                #미리 -1로 체크
#     grid[1][1] = 1
#     for j in range(1,n+1):
#         for k in range(1,m+1):
#             if j == k == 1:                #(1,1)은 1로 만들어두고, 0이 되지 않도록
#                 continue
#             if grid[j][k] == -1:           #웅덩이는 0으로 만들어 다음 덧셈 때 영향끼치지 않게
#                 grid[j][k] = 0
#                 continue
#             grid[j][k] = (grid[j][k-1] + grid[j-1][k])%1000000007   #[a,b] = [a-1,b] + [a,b-1] 공식

#     return grid[n][m]



'''
- 아스키코드, 알파벳함수
  + ord(), chr() ##ordinal position/value(인터넷피셜)
  + .islower()
  + ! 소문자 대문자 케이스 주의
  + .lower() -> a=a.lower() ##반환만하는 형이라, 원래 애 바꾸려 재저장해야함.


  + 알파벳 한 번에 가져오기
    + from string import ascii_lowercase -> set(ascii_lowercase) 

- 문자열 변경 
  + .replace('a','b')

- 'a'.join(# )
  + 입력=반복 객체(5) 1개 & 모든 요소가 str형 => 출력=str 

- 10 초
  + 파이썬_1초에 2천만 번 연산이 가능하다고 보고 계산 => 10초_2억 번

# - [[시간복잡도]] : 20 < 100 -> O(N^4) # n적용 전에 외운 정리 적을 때는 N.
#   + 이전 정리와는, 평균과 항상 되는 케이스의 차이일 수도 있음 # 근데 사람들마다 10 정도 등 조금씩 다르기도 함
#        10이하 N! 
#        20이하 2^N

# N 범위 100 O(N^4)
# N 범위 500 O(N^3)
# N 범위 2x10^3 O(N^2)

# N 범위 10^5 O(NlogN) # 백만은 안되네
# N 범위 10^7 O(N) # 대신 이건 천만이네
- ! 문제에 문자 나올 때 : 케이스_소<->대문자 주의
- str_요소 변경은 안됨 (replace는 커스터마이즈된 변경은아님)-> list화해서 사용. 
- 구간 요소 값들 거꾸로 '가져오기'는 str, list 둘다 가능 str1[ 7: 3: -1 ] 앞이 높은 숫자여야하는거 주의


- 딕셔너리 생성, 조회 
  + 함수. 특히 .update, dict(zip(
    + ```
      >> 1긴 딕셔너리 생성 : [dict(zip())]
      : 1) target=dict(zip( key_list, value_list))
          + list로 입력 줄 때, [0 ]*k 하면 값 동기화 되는지 체크 
  
      : 2) value를 같은 값으로 만들어줄 때 * value를 
        + dict1=dict1.fromkeys( key_list, 3_저장) 
        + fromkeys는 반환형. 
        + 3_디폴트 None 
        + 3_value에 list형 저장하지 마삼. 공유돼버림. 
          + [0]*k는 요소인 0을 복사하는 거라 괜찮지만 [[0]*k]*m에서 m은 요소인 list를 참조해버려서 값이 동기화돼버림. 
  
      >> 2수정&없으면 추가 : [x.update([  [2,'aa'], [3, 'bb'] ]) ]
      : 1) dict1["new"]=1 # new로 하면 변수명으로 인식.
      : 2) x.update( ~ )
      : 2.1) x.update( {1: 'sa' , 3:'a'}) 
      :   input : 한 개의 딕셔너리
  
      : 2.2) x.update([  [2,'aa'], [3, 'bb'] ])
      :   input : 2차원 행열 /  각 행 =[키, 벨류]  
      :   x.update( zip ([2,3], ['aa','bb']) ) # zip_튜플 
  
      : X_2.3) ((키가 문자열일 때))  : x.update(e=90,a=10)  # 1) # 따옴표 빼야함
  
      # 샛기~~셋겟
      >> 3'에러 없는'조회 & 없으면 특정값을 출력&**저장** : [dict1.setdefault(key, 11)]
      : 1) dict1.setdefault(key, 11) 
        >  value 출력, 없는 키면 특정값을 출력 & 저장
        + 해당 키 없으면 원하는 값 반환 가능 
  
      >> 4조회만 & 없으면 특정값을 출력 :[x.get('a',0)]
      : 1) x.get('a',0) # value 출력, 없는 키면 에러 없이 0 출력
      : > <-> dict1[key1]은 원하는 값 반환은 없음
  
      >> 5삭제 
        +  없는 에러 대비 if문 필요. # -> 없을 시 -1을 저장하던지
      : 1) 무조건 특정 키 : dict1.pop('b') # 키라서 얘도 인덱스임
      : 2) 맨 위만 .popitem() 
          + python 3.7부터 공식적으로 딕셔너리 순서 있대[GPT]
          + 딕셔너리의 마지막 항목을 제거 & 그 항목을 튜플 형태로 반환
  
      : 3) del dict1['a'] 
      : 4) 전부 삭제 : dict1.clear()
      ```


- 우선순위큐
  + import heapq
        q=[]
        heapq.heappush(q, (food_times[i], i + 1)) # 음식 시간, 음식 번호
        now = heapq.heappop(q)[0]
'''

