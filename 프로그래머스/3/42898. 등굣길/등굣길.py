# 오른쪽, 아래쪽으로만 움직여서 -> 최단경로의 개수 % 1000000007



# m이 열 n이 행 # N=만 -> O(n log n), n^2아슬
# map만들고  ->
# dp_ 각 map 위치에 최소인 . set
# bfs _ 그 같은 자식들 수 
# (오른쪽이랑 아래쪽으로만 움직여서 가능한 방법)어디서 내려오느냐로 카운팅 & 물웅덩이 개수로 빼서 최적화


    # 2) 
    # m1_X)_너무 최적화하려는 방법은 (웅덩이 등의) 고려할 조건 케이스에 따라 안될 가능성 높음.
    # (n-1)*m# 각 행에서 m개의 열 중에 1개. 행은 1개 빼야함(내려가서 도착하는 위치기준으로 카운팅이기에.)
    # & 단순 m곱하기에는 아래층의 왼쪽에 있는건 못골라서 나머지 열개수에서 골라야함 
    # 근데 물웅덩이가 끝에 있느냐에 따라서 
    
    # m2) -1웅덩이 반영된 map저장. dp맵 거치며 값 저장해나가기. 이전값*(_->곱하기로 하려면 해당 거에 관련된 피연산자값에 해당하는 경우의 수 두개를 다 알아야함. 차근차근 전개하기에 당장 해당 위치 시점에서는  모르는 것도 있으므로 더해나가기.)
    # -> for문 두개로 완전 탐색하며 두 이동경로에 대한 거 -> dp에 계산해나가기
    # m2_m1_X시복초과) 걍 빨리 아는 방법 bfs로 map거쳐서 도착할 때마다(dfs방문했던곳도방문하게) 카운팅할래에? 시복 더 안좋 _ dp좀써보자
    # m3_X)하다가 뭐때문에 안될 수 있을 거 같아서 말았음. 이틀 뒤라 가볍게 한 케이스 생각했던 거 기억은 안나네 ) 아래로 갈 수 있을 때 +1한 거 그 위치에 저장 ~~ 아래로 갈때 자신에서 +1하기 . 마지막 위치에 도달했을 때 answer에+=
    
    ## m_X bfs로 미방문만 가면서 저장_ 미방문만 X 중복 도착해서 경우의 수 추가
    # 3)
    # 가로 세로 전체로 뒤집어도 결과는 같음.
    # 눈에 보이는 가로 4개를 행이 4개인거라고 치고 하자 (데이터 입력 앞위치가 그거임)
#1from collections import deque
def solution(m, n, puddles):
    if  len(puddles[0])==0:
        return 1

    dr,dc=[1,0],[0,1] # 우측 , 아래
    amap=[ [0]*n for _ in range(m) ]
    #visited=[ [False]*n for _ in range(m) ]
    
    dp=[ [0]*n for _ in range(m) ]
    
    for puddle in puddles :
        amap[puddle[0] -1 ][puddle[1] -1 ]=-1 # - 문제 읽을 때 인덱스 -1 미리 적어두자
    
    #aque=deque([ [0,0]  ])
    #visited[0][0]=True
    dp[0][0]=1
    #X 시복초과한 중복방문 bfs법 -> 수정 or 미방문만 : 방문했던 곳이면 append는 안하고 카운팅만추가..? 그럼 값이 다른데
    
    for r in range(m) :
        for c in range(n ) :
            if amap[r][c]==-1:
                continue                
            v=[r,c]
            for i in range(2):
                nr, nc = v[0]+dr[i], v[1]+dc[i]
                if 0<=nr<m and 0<=nc<n and amap[nr][nc]!=-1 : # - 코드수정때 그 앞뒤!! 꼭1_2_3 보듯 다 봐라 쫌. # - 우측, 아래만으로 가는 거라 한 방향으로만 가는 거라서 dp로 for완전탐색 가능. # - bfs 대신 2중 for문으로 하면 완전탐색 완성 기반이라 visited 필요 없어짐
                    #if visited[nr][nc]==True : 
                    dp[nr][nc]+=dp[v[0]][v[1]] # - ! 수정 때 dp[nr][nc] 생각했던 거랑 세부적으로 다른 값을 복사했었 ㅜ. 내부 까지 무슨값인지 자세히 보고 복붙해라. 걍 하나하나 타이핑 하든. # 1이 아니라 현재값. 이전 시복 초과법처럼 각 경우의 수 전부 쭉 가는 거 아님. # - 경우의 수 0->1넘어가기는 +1하는 대신 처음에 초기값이 1인상태로 전파시키는중 
                    # else: # - 처음방문한 곳이어도 이때까지의 값.  
                    # dp[nr][nc]+=dp[v[0]][v[1]] # 1이 아니라 현재값. # 꼭 누적
                    #visited[nr][nc]=True  
                    # m_백트래킹으로 해야하나..
            
    
#     while(aque):
#         #print(dp)
#         v= aque.popleft() 
#         # m 부모의 값을 자식에게 더해줌
#         # 3) x_현재 위치 기준으로 dr의 두방향 다 갈 수 있으면 +1
#         # 라기보다 차라리 방문한곳 또 방문했을 때 거기에 +1 _ 방향특성상돌아가는 건 없다
#         #print(v)
        
#         # 이 방법 조회 순서에 따라#~#~ 중복이 너무 많다. bfs, dfs, 초기에 넣어놓은값 방법 말구 단순 for?
        
#         for i in range(2):
#             nr, nc = v[0]+dr[i], v[1]+dc[i]
#             if 0<=nr<m and 0<=nc<n and amap[nr][nc]!=-1 : # : 코드수정때 그 앞뒤!!꼭123#똑같은 곳 가야하고 뒤로가는거어차피 없어서미방문체크 안해도  visited[nr][nc]==False :
#                 if visited[nr][nc]==True : #i==1:## 두번째가 2가아니라 1이지
#                     #print( dp[v[0]][v[1]]+1 )
#                     dp[nr][nc]+=1##dp[v[0]][v[1]]#+1대신 처음에 초기값이 1인상태로 전파시키는중 # 내려갈 땐 +=는 안해도 
#                 else:
#                     dp[nr][nc]=1#+=dp[v[0]][v[1]] # 꼭 누적
#                 aque.append([nr,nc])
#                 visited[nr][nc]=True                #~ 방문순서와 다르게, 닿는 순서 때문에 여기서 꼭? 
#                 # 기본 pop, append안한거 실화
#     # 22아닌 퍼들값 체크
#     #~aset=set([ [1,2],[1,2],[3,4] ])# 튜플 ㄱㄴ 리스트 ㅂㄱㄴunhashable
#     ##print(aset)
    return dp[-1][-1]% 1000000007
# 4) m, n 1,1아닌 1,k,2
# 물에 잠긴지역 0개일 때 /결과0일떄 완료_중복 물 -> set



# - 저 나눌 값 연산 범위 이려나 -> 설마 코테에서 그렇게 더럽게 문제 내겠어 and print로 나눠봐도 되지


# - 1h 25m (+4점) : 1h제한 풀기로 체크 몇 개 이틀 뒤에 이어서 풀다가 좀 더 걸린듯(복붙도 이상한인덱스로해버림) '4)체크랑  % 1000000007'

#   + 59m : 시복초과한 풀이법. 널널하다고 널널하다고만 생각하지 말고, 시복 계산하자. 
#     + (생각난 여러 방법 중, 빠르게 한 개 픽하지 않고 여러 방법 이어서 생각하다가 시간 들여진듯. 빨리 확실히 픽하지 못할 각 방법 생각 전개였을 수도 있긴 함._풀이법을 계속 bfs로만 전개한 건가. 풀이법 초반에만 bfs로 하고, 효율성은 나중에 생각하고 그 후엔 시복 조건 만족하는 dfs로 하던가하자..)

#   + 1h 제한 문제 풀기(수학문제 처럼 끊는 거 잘 못했는데 보상 거니까 잘되네.)

# - DP!!!!  => !!!!!!!!!점화식!!!!!!!!!

# - 다른 사람 풀이 [정성환 , 이동훈 , 이경서 , 이경서 외 24 명]
#   + 인덱스 헷갈리니까 걍 index 1,1 부터 사용 . & k-1인덱스 사용하는 점화식때 첫 실제 줄의 값도 연산되기 위해 0 패딩 유사.
#      >  = [[0]*(m+1) for i in range(n+1)]

#   + 점화식 사용. 일방향 유사 조건에서 가능했던 내 간이 dp말고 찐 점화식 dp네. 
#     + 점화식 덧셈에 문제 없기 위해, 물웅덩이 때의 dp값을 0으로하면 ㄱㅊ
#   + 애초에 dp에도 그 큰 수 나눈 나머지의 값으로 저장
#     + 더하기가 결합된 것의 괄호 밖 나누기(~~나머지)를 괄호 안으로 분배해도 결과 같음. 

# def solution(m,n,puddles):
#     grid = [[0]*(m+1) for i in range(n+1)] #왼쪽, 위로 한줄씩 만들어서 IndexError 방지
#     if puddles != [[]]:                    #물이 잠긴 지역이 0일 수 있음
#         for a, b in puddles:
#             grid[b][a] = -1                #미리 -1로 체크
#     grid[1][1] = 1
#     for j in range(1,n+1):
#         for k in range(1,m+1):
#             if j == k == 1:                #(1,1)은 1로 만들어두고, 0이 되지 않도록
#                 continue
#             if grid[j][k] == -1:           #웅덩이는 0으로 만들어 다음 덧셈 때 영향끼치지 않게
#                 grid[j][k] = 0
#                 continue
#             grid[j][k] = (grid[j][k-1] + grid[j-1][k])%1000000007   #[a,b] = [a-1,b] + [a,b-1] 공식

#     return grid[n][m]