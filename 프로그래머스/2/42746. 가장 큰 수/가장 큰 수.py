# 0 이상의 정수 0 -> 정수 붙여 만들 수 있는 가장 큰 수 

# 2) 십만 -> O(nlogn)
# m1_ 전체 -> max()
# m2_앞대가리 높은 숫자부터 미리 sort -> 9가 98보다 우선. 
# 0 처리

# str -> ord로 바꿔서 요소요소 sort?
# 한자리와 두자리 : 7 75 # 똑같은 숫자 있으면 그 다음꺼 붙여서 더 높은? 보단 넘버 훑으며 중간에 넣기? 
# 9로 시작하는 거 : 9,10,10,10 -> 9,4 ->9,3,3 # 높은 순으로 할꺼라 한자리면 최대값 10_X_ 3x 34 : 3333 으로 우선순위해둬야하나_ 마지막 숫자  34 
# 맨마지막 요소에 길이 붙여놓고 길이 만큼.
# 17_ _ 17_1_6_ 17_9_4_ 15

# 1 0 0 0  1 111
# 17_7말고"(높아봤자_다음가능한숫자_그건 a,b보다 작음.자가복제?_완전똑같으면 짧은거먼저쓰면되니_그후최대값인자기자신값_ 15였으면?)""->_(17)  177(177) 그 뒤에 1보다 큰게 앞인거 먼저 나올일 없어서 무조건 후자가나음 -> 앞 숫자보다 작은지 큰지? 17717 17177 그 뒷숫자가 앞숫자보다 큰지 하드코딩? [ a vs b : ab ba 중에 더 큰거->lamba에서 두 요소 이용불가-> \더 작은 c는 a,b다 쓰고 나서니까.  \ X_짧은쪽에 c붙여서 비교]

# ((나머지가 16  15 있으면,  다음 숫자나 4자리다비교해야하는거아닌가
# => 다음 숫자 붙여보고 더 높은 수 붙이기 자릿수때문에 다를 수 있는데, 둘다 붙여높으면 자릿수 같음 _ 그렇게 정렬하드코딩을 lambda로 하기엔. 두 요소값다 이용해야함. 
#X_그냥 해당값 먼저했을떄랑 아닌 것중에 더 큰거이어서 
# sort = n logn <-> heapq

# - 각 10 숫자에서 각각정렬이 나으려나 : 4이면 


# 요소수까지하면 nlogn개클수도 있겠는데. 최대길이_4*n이라 상수라 ㄱㅊ
def solution(numbers):
    # push pop 다 할 거면 nlogn <-> n,. # 디큐의 sort는 ? 
    q=[]
    for number in numbers : # 277
        str_number = str(number)# '277'
        q_part= [ int(one) for one in str_number] # [2,7,7]
        for i in range( 4-len(q_part) ): # 5 길이만큼 자가복제 & 나중에 쓸때는 길이만큼만
            #5                
            q_part.append( q_part[i])#~int(str_number[i] ) ) 
        q_part.append(len(str_number)) # 길이저장
        # str_number+'x'*(4-len(str_number)) 
        q.append(q_part)
    q.sort(reverse=True)
    # 10아닌 거 붙이기
    #print(q)        

    answer = ''
    for target in q: # [2,7,2,7,2]
        for i in  range( len(target)) :
            if i >= target[-1] : # 길이넘으면
                break
            answer+= str( target[i] )
            #print(i)
    if answer[0]=="0": # 가장 큰숫자가 0이라는 거임. 0으로만 1개이상 이어진 경우
        answer="0"
    return answer
# 4) numbers길이 1, 
# 원소 0, 


# - 1h: 시간초과로 테스트케이스 1개 질문방에서 값봄
#   >  54m : 1문제 틀림 
#   + [0,0] -> "0" : 0주의 :'int 0'은 '붙여도' '0'. | 길이는 1부터여도 2까지 보기? 
#  이전풀었던문제 들

