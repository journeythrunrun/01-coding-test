# if x%3==0 : x//3
# if x%2==0 : x//2
# x-=1
# -> 1로 만들 때 연산을 사용하는 최소횟수

# 2) N <= 10^6
# 값은 빨리 하락하는 게 좋으니까 1->2->3 순위 6
N=int(input())

# - m1, m2 틀림! 방법 엄밀히 따지기 !. 
#   + "2-2)로 위배될 특이한값 예외케이스 생각해보기"
# m1) 연산순위 1->2->3아님
# m2)_노엄밀_1에서 N만들기?  -> *3우선.(세제곱근모름)  *2 , +1
## 막판에 3으로 큰값 안곱해지고(&+1개많이) 2곱해서 딱 맞춰줬을 경우도 있음
## 중간에-1해야지 그후에 딱 나눠떨어지게 되는 경우도 있을거임

# - 세제곱근 : x**(1/3), 3**k승

# - m3) dp [세 연산을 선택했을 때 나오는 dp[]값중 작은거 선택.] (나열해보다가 번뜩 떠오름. 또 어차피 [경우의 수 3으로 매우 적음 -> DP min()]) 
# dp[1]=0, dp[2]=1,dp[3]=1, dp[4]=2 -> dp[10] =3  (3^2+1 )
# m_other) x=3^a + 2^b +c # a+b+c의 최소값 / 이진탐색하기엔 변수처리 조금 귀찮 a+b+
# m_other) ##각 3^k들이 최적최솟값 dp로 최적해 확장 3의 제곱 반복 2의 제곱반복 후 number의 근처 찾기는 3*2 섞인 거도 귀찮아짐
    
# - [dp] : '작은범위케이스부터 순차적. 수열 규칙찾듯'
# - 0) dp[i] : 숫자 i를 만들기 위한 최소 횟수  | 정의 보통 ==정답
dp=[0,0,1,1,2]# dp[1]=0, dp[2]=1,dp[3]=1, dp[4]=2 
# -> dp[10] =3 (_3^2+1 ) [세 연산을 선택했을 때 나오는 dp[]값중 작은거 선택.]

# - 최소 - > dp로 min(  ,  , ) 압축골라나가기
# - reverse가 필요하면 해서라도 [작은 연산범위 방향부터 dp에 누적하여 저장]해나가기

for i in range(5,N+1):
    # - 이렇게 한칸씩 해도 최적해인지 
    #   + ~인지 엄밀체크라기보단 오히려 한칸씩 i에서의 최소횟수 구하는 게 엄밀히 맞는 말
    #   + 횟수라 & 사칙 연산 특성 상 반대 방향으로 카운팅해도 횟수는 같음
    target=[dp[i-1]]
    if i%3==0:
        target.append(dp[i//3])
    if i%2==0:
        target.append(dp[i//2])
    dp.append(min(target)+1 )# - 미리 전체 길이 생성해준 거 아니니까 []니까 dp[i]=아니고 append지. 
    # - 아님_min(dp[i//3],dp[i//2],dp[i-1])+1
    #    > //하면 딱 해당 dp말고 나머지 근처 떨거지들도 같은 값 취급이잖아
print(dp[N], end='')
# 4) N=1,2.. ##음수, 0없음

# - 10^6승 -> 아래로 O(n)

# - 41m(실버3) 
#   > (집중 놓친 적은 시간?은 시험 때도 있을 거임. 그래도 시험 때 +1분 더 쓸 시간은 있겠지~)
#   + 제출 틀린 타이밍 : 20m 

# - 다른 사람 풀이 
#   > 하향식으로 구현하셨는데 난 함수 쌓이는 거 길이 등등의 이유로 상향식 추구. 
#   + 모든 n을 돌지 않고 3,2나눈거 재귀함수 돌리고 부차적인값은 +x%2 처럼 해주심 # t= 1(오른쪽의 연산을 하는비용. min으로 택함.)+ min(fib(x//3)+x%3, fib(x//2)+x%2)[https://www.acmicpc.net/source/83039630]
#   + 상향식에서 3이나 2씩 건너가서 계산하고 짜부랭이 값 따로 하기엔 코드 더러워짐
#   + 내가 m_other)에서 생각한 3,2 & 근처값처리는 하향식 방식으로 저렇게 구현할 수 있군. 물론 나머지 있는 위치들 덜 구해진 부분있겠지만 target에 대한 거만 필요한 나머지 찌끄랭이도 더하면 될 뿐, 해당값까지의 모든 정수에 대해서 구해야하는 건 아님

# dic={1:0,2:1,3:1}
# def fib(x: int) -> int: #타입힌트, int로 입력받고 int로 반환하는 함수라는 뜻. 함수 에러만 안난다면 힌트무시하고 다른자료형 넣어도 됨
#     if x in dic: #if x in list(dic.keys())
#         return dic[x]
#     t= 1+ min(fib(x//3)+x%3, fib(x//2)+x%2)
#     ''' 나눠진다는 조건에 목 맬 필요없이 냅다 나눠서
#     나머지는 -1 연산 쓴다고 생각하고 더해주기
#     //3 //2 두 가지 중에 더 적은 연산으로 만들어진 아이를 택함'''
#     dic[x]=t
#     return t
# print(fib(int(input()))) #x=int(input()) 앞에 이런거 안쓰고 코드 줄일수도있구나